<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線條射擊 v13.0 (舒適抗暈版)</title>
    <style>
        /* --- 全局配色：北歐深藍灰 --- */
        body { margin: 0; overflow: hidden; background-color: #2c3e50; font-family: 'Consolas', monospace; user-select: none; color: #ecf0f1; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* --- 抗暈眩暗角 (Vignette) --- */
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 100%);
        }

        /* 資訊面板：半透明磨砂感 */
        #info { 
            position: absolute; top: 20px; left: 20px; 
            background: rgba(44, 62, 80, 0.7); padding: 15px; border-radius: 8px; border: 1px solid #7f8c8d;
            font-weight: bold; font-size: 16px; line-height: 1.6; backdrop-filter: blur(2px);
        }
        .stat-label { color: #bdc3c7; font-weight: normal; }
        .val-highlight { color: #fff; }

        #level-indicator { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            font-size: 28px; color: #74b9ff; font-weight: bold; text-shadow: 0 0 10px rgba(116, 185, 255, 0.3);
        }

        /* 準心：中心加點，幫助視線聚焦 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; transform: translate(-50%, -50%);
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #ecf0f1; opacity: 0.9; }
        #crosshair::before { top: 11px; left: 0; width: 24px; height: 2px; }
        #crosshair::after { top: 0; left: 11px; width: 2px; height: 24px; }
        /* 中心點 */
        #crosshair-dot {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #e74c3c; 
            transform: translate(-50%, -50%); border-radius: 50%;
        }

        #minimap-container {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 160px;
            background: rgba(44, 62, 80, 0.9); border: 2px solid #95a5a6; border-radius: 12px; overflow: hidden;
        }

        #msg-display {
            position: absolute; top: 65%; left: 50%; transform: translateX(-50%);
            color: #f1c40f; font-size: 26px; display: none; font-weight: bold; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3); text-align: center;
        }

        #blocker {
            position: absolute; width: 100%; height: 100%; background-color: rgba(44, 62, 80, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #ecf0f1; z-index: 20; pointer-events: auto;
        }
        .panel { 
            text-align: center; border: 1px solid #74b9ff; padding: 40px; 
            background: #34495e; box-shadow: 0 0 40px rgba(0,0,0,0.2); max-width: 500px; border-radius: 8px;
        }
        .key { display: inline-block; border: 1px solid #95a5a6; background: #2c3e50; padding: 2px 8px; border-radius: 4px; margin: 0 4px; font-weight: bold; color: #fff;}
        
        table { width: 100%; margin-top: 15px; border-collapse: collapse; }
        th, td { border-bottom: 1px solid #7f8c8d; padding: 8px; text-align: left; color: #ecf0f1; }
        th { color: #74b9ff; }

        #name-input { 
            font-size: 24px; text-align: center; width: 150px; letter-spacing: 5px; 
            text-transform: uppercase; border: none; border-bottom: 2px solid #74b9ff; background: transparent; color: #fff;
            margin: 20px 0; outline: none;
        }
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%; background: #2c3e50; color: #74b9ff;
            display: flex; justify-content: center; align-items: center; z-index: 999; font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="loader">INITIALIZING...</div>
    
    <div id="vignette"></div>

    <div id="ui-layer">
        <div id="info">
            <div><span class="stat-label">SCORE:</span> <span id="score" class="val-highlight">0</span></div>
            <div><span class="stat-label">HP:</span> <span id="health" style="color:#2ecc71">100</span> / <span id="max-hp">100</span></div>
            <div><span class="stat-label">AMMO:</span> <span id="ammo" class="val-highlight">30/60</span></div>
            <div><span class="stat-label">NADE:</span> <span id="grenades" class="val-highlight">0</span></div>
            <div style="margin-top:10px; font-size:13px; color:#95a5a6; border-top:1px solid #7f8c8d; padding-top:8px;">
                <div>DMG: <span id="stat-dmg" class="val-highlight">100%</span> <span class="stat-label">|</span> SPD: <span id="stat-spd" class="val-highlight">250</span></div>
                <div>DEF: <span id="stat-def" class="val-highlight">0%</span> <span class="stat-label">|</span> RATE: <span id="stat-rate" class="val-highlight">6.6/s</span></div>
            </div>
        </div>
        
        <div id="level-indicator">LEVEL <span id="level">1</span></div>
        <div id="crosshair"><div id="crosshair-dot"></div></div>
        <div id="msg-display"></div>
        <div id="minimap-container"><canvas id="minimap" width="160" height="160"></canvas></div>
    </div>

    <div id="blocker" style="display:none;">
        <div id="start-screen" class="panel">
            <h1 style="margin:0 0 20px 0; color:#74b9ff; letter-spacing: 2px;">COMFORT SHOOTER v13</h1>
            <p style="color:#bdc3c7;">視野已擴大，色調已柔和化</p>
            <div style="margin: 20px 0; text-align: left; display: inline-block;">
                <p><span style="color:#ff7675">■</span> <b>柔紅</b> = 普通敵人</p>
                <p><span style="color:#a29bfe">■</span> <b>淡紫</b> = 坦克 (硬)</p>
                <p><span style="color:#55efc4">◆</span> <b>薄荷</b> = 脈衝怪 (快)</p>
                <p>⬜ <b>白框</b> = 手榴彈包</p>
            </div>
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移動 <span class="key">R</span> 換彈 <span class="key">G</span> 手榴彈</p>
            <div id="high-score-display" style="margin-top:20px; color:#74b9ff; font-size:14px;"></div>
        </div>

        <div id="game-over-screen" class="panel" style="display:none;">
            <h1 style="color:#e74c3c; margin:0;">GAME OVER</h1>
            <p style="font-size:18px;">FINAL SCORE: <span id="final-score">0</span></p>
            <div id="input-section">
                <p>ENTER INITIALS:</p>
                <input type="text" id="name-input" maxlength="3" placeholder="AAA" autofocus>
                <br>
                <button onclick="saveScoreAndRestart()" style="padding:10px 20px; cursor:pointer; background:#2c3e50; color:#fff; border:1px solid #74b9ff; margin-top:15px;">SAVE RECORD</button>
            </div>
            <div id="leaderboard-section" style="display:none;">
                <h3>TOP RECORDS</h3>
                <table id="leaderboard-table"></table>
                <br>
                <button onclick="restartGame()" style="padding:10px 20px; cursor:pointer; background:#2c3e50; color:#fff; border:1px solid #74b9ff;">RESTART</button>
            </div>
        </div>
    </div>

    <script>window.onerror = function(msg) { alert("Error: " + msg); };</script>
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // --- 音效系統 (音量調低一點點，更舒適) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const SoundFX = {
            playTone: (freq, type, duration, vol=0.08) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + duration);
            },
            shoot: () => { SoundFX.playTone(600, 'square', 0.1, 0.04); }, // 頻率降低不刺耳
            pickup: () => { SoundFX.playTone(1000, 'sine', 0.1, 0.08); setTimeout(()=>SoundFX.playTone(1500,'sine',0.2,0.08), 50); },
            ammo: () => { SoundFX.playTone(500, 'square', 0.1, 0.08); },
            reload: () => { SoundFX.playTone(300, 'triangle', 0.1, 0.08); },
            explosion: () => { SoundFX.playTone(80, 'sawtooth', 0.4, 0.15); },
            damage: () => { SoundFX.playTone(120, 'sawtooth', 0.2, 0.15); },
            levelUp: () => { SoundFX.playTone(440, 'sine', 0.2); setTimeout(()=>SoundFX.playTone(660,'sine',0.4), 100); }
        };

        window.onload = function() {
            if (typeof THREE === 'undefined') { alert("Libs load failed."); return; }
            document.getElementById('loader').style.display = 'none';
            document.getElementById('blocker').style.display = 'flex';
            updateHighScoreDisplay();
            init(); animate();
        };

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isFiring = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        let gun;
        const bullets = [];
        const enemies = [];
        const enemyBullets = [];
        const items = [];
        const grenades = [];
        const explosions = [];

        const MAP_SIZE = 200; 
        const MAP_LIMIT = 95; 
        const BASE_SPEED = 250.0;
        
        const playerStats = { maxHp: 100, defense: 0, speedMult: 1.0, damageMult: 1.0, fireRate: 150, clipSize: 30 };
        let score = 0, health = 100, isGameOver = false;
        let ammoInClip = 30, totalAmmo = 60, grenadeCount = 0, isReloading = false;
        let level = 1, enemySpawnRate = 2000, lastSpawnTime = 0, lastShotTime = 0;

        // --- 莫蘭迪柔和色調 (Morandi/Pastel Palette) ---
        const COLORS = {
            bg: 0x2c3e50,          // 背景：深藍灰 (Midnight Blue)
            grid: 0x34495e,        // 網格：稍亮的藍灰 (Wet Asphalt)
            gridCenter: 0x7f8c8d,  // 中線：水泥灰 (Asbestos)
            border: 0xe74c3c,      // 邊界：柔和紅 (Alizarin)
            playerBullet: 0x74b9ff,// 子彈：柔和天藍
            
            enemyNormal: 0xff7675, // 敵人：柔和粉紅
            enemyTank: 0xa29bfe,   // 坦克：薰衣草紫
            enemyPulse: 0x55efc4,  // 脈衝：薄荷綠
            
            gun: 0x74b9ff          // 槍：柔和藍
        };

        // 道具顏色也改為粉嫩系
        const lootTable = [
            { type: 'health', weight: 10, color: 0x55efc4, label: "HEALTH RECOVER" }, // 薄荷綠
            { type: 'grenade', weight: 15, color: 0xffffff, label: "GRENADE PACK" },
            { type: 'max_hp', weight: 10, color: 0x81ecec, label: "MAX HP UP" },      // 青色
            { type: 'defense', weight: 10, color: 0x74b9ff, label: "DEFENSE UP" },    // 天藍
            { type: 'speed', weight: 10, color: 0xfdcb6e, label: "SPEED UP" },        // 奶油黃
            { type: 'damage', weight: 10, color: 0xff7675, label: "DAMAGE UP" },      // 粉紅
            { type: 'fire_rate', weight: 10, color: 0xffeaa7, label: "FIRE RATE UP" },// 淺黃
            { type: 'clip_size', weight: 10, color: 0xb2bec3, label: "CLIP SIZE UP" } // 淺灰
        ];

        const dom = {
            score: document.getElementById('score'),
            health: document.getElementById('health'),
            maxHp: document.getElementById('max-hp'),
            ammo: document.getElementById('ammo'),
            grenades: document.getElementById('grenades'),
            level: document.getElementById('level'),
            msg: document.getElementById('msg-display'),
            statDmg: document.getElementById('stat-dmg'),
            statSpd: document.getElementById('stat-spd'),
            statDef: document.getElementById('stat-def'),
            statRate: document.getElementById('stat-rate'),
            minimap: document.getElementById('minimap').getContext('2d')
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.bg);
            // 霧氣顏色完美融合背景，減少邊緣撕裂感
            scene.fog = new THREE.Fog(COLORS.bg, 0, 100);

            // --- 關鍵修改：FOV 90 ---
            // 提升 FOV 到 90 度，符合 PC FPS 標準，大幅減少暈眩感
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.PointerLockControls(camera, document.body);
            const startScreen = document.getElementById('start-screen');
            const blocker = document.getElementById('blocker');

            startScreen.addEventListener('click', () => { 
                if(!isGameOver) {
                    controls.lock(); 
                    if(audioCtx.state === 'suspended') audioCtx.resume();
                }
            });
            controls.addEventListener('lock', () => { startScreen.style.display = 'none'; blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { if (!isGameOver) { blocker.style.display = 'flex'; startScreen.style.display = 'block'; startScreen.innerHTML = '<h1>PAUSED</h1><p>點擊繼續</p>'; }});

            scene.add(controls.getObject());

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => { if(e.button===0) isFiring = true; });
            document.addEventListener('mouseup', () => { isFiring = false; });
            window.addEventListener('resize', onWindowResize);

            buildWorld();
            createGun();
            spawnLootBox(new THREE.Vector3(0, 0.5, -5), 'grenade');
            updateUI();
        }

        function buildWorld() {
            // 地板與天花板，使用低對比顏色
            const floorGrid = new THREE.GridHelper(MAP_SIZE, 50, COLORS.gridCenter, COLORS.grid);
            scene.add(floorGrid);
            const ceilingGrid = new THREE.GridHelper(MAP_SIZE, 20, COLORS.gridCenter, COLORS.grid);
            ceilingGrid.position.y = 10;
            scene.add(ceilingGrid);

            const borderGeo = new THREE.BoxGeometry(MAP_SIZE, 10, MAP_SIZE);
            const borderEdges = new THREE.EdgesGeometry(borderGeo);
            // 邊界顏色柔和一點
            const borderMat = new THREE.LineBasicMaterial({ color: COLORS.border, transparent: true, opacity: 0.2 });
            const border = new THREE.LineSegments(borderEdges, borderMat);
            border.position.y = 5;
            scene.add(border);
        }

        function createGun() {
            const gunGeo = new THREE.BoxGeometry(0.15, 0.2, 0.6);
            const gunEdges = new THREE.EdgesGeometry(gunGeo);
            const gunMat = new THREE.LineBasicMaterial({ color: COLORS.gun });
            gun = new THREE.LineSegments(gunEdges, gunMat);
            gun.position.set(0.25, -0.25, -0.4);
            camera.add(gun);
        }

        function onKeyDown(e) {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyR': reload(); break;
                case 'KeyG': throwGrenade(); break;
            }
        }
        function onKeyUp(e) {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function shoot() {
            if (isReloading || ammoInClip <= 0) {
                if(ammoInClip <= 0 && !isReloading) showMsg("NO AMMO", 1000);
                return;
            }
            lastShotTime = performance.now();
            ammoInClip--; updateUI();
            gun.position.z += 0.2; 
            SoundFX.shoot();

            const isStrong = playerStats.damageMult > 1.5;
            const bGeo = new THREE.BoxGeometry(isStrong?0.08:0.04, isStrong?0.08:0.04, 1.5);
            const bMat = new THREE.MeshBasicMaterial({ color: isStrong ? 0xff7675 : COLORS.playerBullet });
            const bullet = new THREE.Mesh(bGeo, bMat);

            const vector = new THREE.Vector3(); gun.getWorldPosition(vector); bullet.position.copy(vector);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            bullet.lookAt(bullet.position.clone().add(dir));
            bullet.velocity = dir.multiplyScalar(80);
            bullet.creationTime = performance.now();
            bullet.damage = 1 * playerStats.damageMult;

            bullets.push(bullet); scene.add(bullet);
        }

        function throwGrenade() {
            if (grenadeCount <= 0) { showMsg("NO GRENADES", 1000); return; }
            grenadeCount--; updateUI();
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const nade = new THREE.LineSegments(new THREE.EdgesGeometry(geo), mat);
            const vector = new THREE.Vector3(); gun.getWorldPosition(vector); nade.position.copy(vector);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            nade.velocity = dir.multiplyScalar(25); nade.velocity.y += 10;
            grenades.push(nade); scene.add(nade);
        }

        function explode(position) {
            SoundFX.explosion();
            const geo = new THREE.SphereGeometry(1, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff7675, wireframe: true, transparent: true, opacity: 1 });
            const explosion = new THREE.Mesh(geo, mat);
            explosion.position.copy(position); explosion.scaleVal = 1;
            explosions.push(explosion); scene.add(explosion);

            const radius = 8.0;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.position.distanceTo(position) < radius) {
                    takeDamage(e, 5 * playerStats.damageMult, i);
                }
            }
        }

        function enemyShoot(enemy) {
            SoundFX.shoot();
            const ebGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const ebMat = new THREE.MeshBasicMaterial({ color: enemy.baseColor }); 
            const bullet = new THREE.Mesh(ebGeo, ebMat);
            bullet.position.copy(enemy.position);
            const target = camera.position.clone(); target.y -= 0.5; 
            bullet.lookAt(target);
            const dir = target.sub(enemy.position).normalize();
            bullet.velocity = dir.multiplyScalar(15); 
            bullet.creationTime = performance.now();
            bullet.damage = 10; 
            enemyBullets.push(bullet); scene.add(bullet);
        }

        function takePlayerDamage(amount) {
            SoundFX.damage();
            const finalDmg = Math.max(1, Math.floor(amount * (1 - playerStats.defense)));
            health -= finalDmg;
            updateUI();
            document.body.style.backgroundColor = '#e74c3c'; // 柔和紅
            setTimeout(() => document.body.style.backgroundColor = '#2c3e50', 100);
            if (health <= 0) endGame();
        }

        function spawnEnemy() {
            if (!controls.isLocked || isGameOver) return;
            
            let type = 'normal'; let color = COLORS.enemyNormal; 
            let hp = 1 + (level * 0.5); let speed = 6 + (level * 0.2); let canShoot = true;
            let geometry = new THREE.BoxGeometry(1.2, 2.0, 1.2);
            let edges = new THREE.EdgesGeometry(geometry);

            const rand = Math.random();
            if (level >= 2 && rand < 0.2) { 
                type = 'tank'; color = COLORS.enemyTank; 
                geometry = new THREE.BoxGeometry(2.0, 3.0, 2.0); 
                edges = new THREE.EdgesGeometry(geometry);
                hp = 5 + (level * 1.5); speed = 3; canShoot = false; 
            }
            else if (level >= 3 && rand < 0.45) { 
                type = 'pulse'; color = COLORS.enemyPulse; 
                geometry = new THREE.OctahedronGeometry(0.8); 
                edges = new THREE.EdgesGeometry(geometry);
                hp = 1 + (level * 0.2); speed = 10; canShoot = true; 
            }

            const mat = new THREE.LineBasicMaterial({ color: color });
            const enemy = new THREE.LineSegments(edges, mat);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 50;
            let ex = camera.position.x + Math.cos(angle) * radius;
            let ez = camera.position.z + Math.sin(angle) * radius;
            ex = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, ex));
            ez = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, ez));

            enemy.position.set(ex, type==='pulse'?1.0:1.0, ez);
            enemy.type = type; enemy.hp = hp; enemy.maxHp = hp; enemy.baseColor = color; enemy.speed = speed;
            enemy.flashTime = 0; enemy.canShoot = canShoot; enemy.lastAttack = 0;
            enemy.attackRate = type === 'pulse' ? 1500 : 3000;
            enemies.push(enemy); scene.add(enemy);
        }

        function spawnLootBox(position, specificType) {
            let selectedItem;
            if (specificType) {
                selectedItem = lootTable.find(i => i.type === specificType);
            } else {
                let totalWeight = 0; lootTable.forEach(i => totalWeight += i.weight);
                let random = Math.random() * totalWeight;
                selectedItem = lootTable[0];
                for (let item of lootTable) {
                    if (random < item.weight) { selectedItem = item; break; }
                    random -= item.weight;
                }
            }
            const item = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1)), new THREE.LineBasicMaterial({ color: selectedItem.color }));
            item.position.copy(position); item.position.y = 0.5; item.props = selectedItem; item.isBox = true; 
            items.push(item); scene.add(item);
        }

        function spawnAmmoDrop(position) {
            const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const edges = new THREE.EdgesGeometry(geo);
            const item = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffeaa7 })); // 淡黃
            item.position.copy(position); item.position.y = 0.5; item.isAmmo = true; item.props = { type: 'ammo_pack', label: 'AMMO PACK' };
            items.push(item); scene.add(item);
        }

        function checkDrops(enemy) {
            const pos = enemy.position.clone();
            if (Math.random() < 0.3) spawnLootBox(pos);
            if (Math.random() < 0.5) { 
                const ammoPos = pos.clone(); ammoPos.x += (Math.random()-0.5)*1.5; ammoPos.z += (Math.random()-0.5)*1.5;
                spawnAmmoDrop(ammoPos); 
            }
        }

        function applyItemEffect(item) {
            const type = item.props.type;
            let msg = item.props.label;
            
            if (item.isAmmo) {
                SoundFX.ammo();
                totalAmmo += 15;
                msg = "AMMO +15";
            } else {
                SoundFX.pickup();
                switch(type) {
                    case 'health': health = Math.min(health + 50, playerStats.maxHp); break;
                    case 'grenade': grenadeCount += 2; break;
                    case 'max_hp': playerStats.maxHp += 10; health += 10; msg += " (+10)"; break;
                    case 'defense': playerStats.defense = Math.min(playerStats.defense + 0.05, 0.6); msg += " (+5%)"; break;
                    case 'speed': playerStats.speedMult += 0.1; msg += " (+10%)"; break;
                    case 'damage': playerStats.damageMult += 0.2; msg += " (+20%)"; break;
                    case 'fire_rate': playerStats.fireRate = Math.max(50, playerStats.fireRate - 10); msg += " (FASTER)"; break;
                    case 'clip_size': playerStats.clipSize += 5; msg += " (+5)"; break;
                }
            }
            showMsg(msg, 1000);
            updateUI();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!controls.isLocked || isGameOver) return;
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (isFiring && time - lastShotTime > playerStats.fireRate) shoot();

            // --- 抗暈眩：摩擦力調整 ---
            // 增加摩擦力係數 (10 -> 15)，讓煞車更靈敏，減少滑動感
            velocity.x -= velocity.x * 15.0 * delta;
            velocity.z -= velocity.z * 15.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            const currentSpeed = BASE_SPEED * playerStats.speedMult;
            if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;
            
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            const pos = camera.position;
            pos.x = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, pos.x));
            pos.z = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, pos.z));

            gun.position.z = THREE.MathUtils.lerp(gun.position.z, -0.4, 0.1);

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.velocity.clone().multiplyScalar(delta));
                if (time - b.creationTime > 2000) { scene.remove(b); bullets.splice(i, 1); continue; }
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (b.position.distanceTo(enemies[j].position) < (enemies[j].type==='tank'?2.0:1.5)) {
                        takeDamage(enemies[j], b.damage, j);
                        scene.remove(b); bullets.splice(i, 1); break;
                    }
                }
            }

            const pPos = camera.position;
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.position.add(b.velocity.clone().multiplyScalar(delta));
                if (time - b.creationTime > 3000) { scene.remove(b); enemyBullets.splice(i, 1); continue; }
                if (b.position.distanceTo(pPos) < 1.0) { takePlayerDamage(b.damage); scene.remove(b); enemyBullets.splice(i, 1); }
            }

            if (time - lastSpawnTime > enemySpawnRate) { spawnEnemy(); lastSpawnTime = time; }
            if (Math.random() < 0.001) { 
                const x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                const z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                spawnLootBox(new THREE.Vector3(x, 0.5, z)); 
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.flashTime > 0) { e.flashTime -= delta; if (e.flashTime <= 0) e.material.color.setHex(e.baseColor); }
                if (e.type === 'pulse') { e.rotation.x += delta * 2; e.rotation.y += delta * 2; }

                const distToPlayer = e.position.distanceTo(pPos);
                const dir = pPos.clone().sub(e.position); dir.y = 0; dir.normalize();
                
                const nextPos = e.position.clone().add(dir.multiplyScalar(e.speed * delta));
                if (nextPos.x > -MAP_LIMIT && nextPos.x < MAP_LIMIT && nextPos.z > -MAP_LIMIT && nextPos.z < MAP_LIMIT) {
                    e.position.copy(nextPos);
                }
                
                e.lookAt(pPos);
                if (e.canShoot && distToPlayer < 40 && time - e.lastAttack > e.attackRate) { enemyShoot(e); e.lastAttack = time; }
                if (distToPlayer < 1.5) { takePlayerDamage(15); scene.remove(e); enemies.splice(i, 1); }
            }

            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i]; 
                if(it.isBox) {
                    it.position.y = 0.5 + Math.sin(time * 0.003) * 0.2;
                    it.rotation.y += delta;
                } else if (it.isAmmo) {
                    it.rotation.x += delta * 3;
                    it.rotation.z += delta * 3;
                }

                if (it.position.distanceTo(pPos) < 2.0) {
                    applyItemEffect(it);
                    scene.remove(it); items.splice(i, 1);
                }
            }
            
            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i]; g.velocity.y -= 30 * delta; g.position.add(g.velocity.clone().multiplyScalar(delta));
                g.rotation.x += delta * 5; g.rotation.y += delta * 5;
                if (g.position.y <= 0.1) { explode(g.position); scene.remove(g); grenades.splice(i, 1); }
            }
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i]; ex.scaleVal += 15 * delta; ex.scale.set(ex.scaleVal, ex.scaleVal, ex.scaleVal);
                ex.material.opacity -= 2 * delta;
                if (ex.material.opacity <= 0) { scene.remove(ex); explosions.splice(i, 1); }
            }

            drawMinimap();
            renderer.render(scene, camera);
        }

        function takeDamage(enemy, dmg, index) {
            enemy.hp -= dmg;
            enemy.flashTime = 0.1; enemy.material.color.setHex(0xffffff);
            const pushDir = enemy.position.clone().sub(camera.position).normalize();
            enemy.position.add(pushDir.multiplyScalar(0.5));
            if (enemy.hp <= 0) {
                SoundFX.explosion();
                checkDrops(enemy);
                scene.remove(enemy); enemies.splice(index, 1);
                score += (enemy.type === 'tank' ? 50 : 10);
                if (score >= level * 150) { 
                    level++; enemySpawnRate = Math.max(800, 2000-(level*150)); 
                    showMsg("LEVEL UP!", 2000); SoundFX.levelUp();
                }
                updateUI();
            }
        }

        function reload() {
            if (isReloading || ammoInClip >= playerStats.clipSize || totalAmmo <= 0) return;
            SoundFX.reload();
            isReloading = true; showMsg("RELOADING...", 1000);
            setTimeout(() => {
                const needed = playerStats.clipSize - ammoInClip;
                const toAdd = Math.min(needed, totalAmmo);
                ammoInClip += toAdd; totalAmmo -= toAdd;
                isReloading = false; updateUI();
            }, 1500);
        }

        function showMsg(text, duration) {
            dom.msg.innerText = text; dom.msg.style.display = "block";
            if (duration) setTimeout(() => dom.msg.style.display = "none", duration);
        }

        function updateUI() {
            dom.score.innerText = score;
            dom.health.innerText = health;
            dom.maxHp.innerText = playerStats.maxHp;
            dom.ammo.innerText = `${ammoInClip}/${totalAmmo}`;
            dom.grenades.innerText = grenadeCount;
            dom.level.innerText = level;
            dom.statDmg.innerText = Math.round(playerStats.damageMult * 100) + "%";
            dom.statSpd.innerText = Math.round(BASE_SPEED * playerStats.speedMult);
            dom.statDef.innerText = Math.round(playerStats.defense * 100) + "%";
            dom.statRate.innerText = (1000/playerStats.fireRate).toFixed(1) + "/s";
        }

        function drawMinimap() {
            const ctx = dom.minimap;
            ctx.fillStyle = 'rgba(44, 62, 80, 0.9)'; ctx.fillRect(0, 0, 160, 160);
            ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 2; ctx.strokeRect(0,0,160,160);
            const cx = 80, cy = 80, range = MAP_SIZE / 2, scale = 80 / range;
            
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            ctx.fillStyle = '#ecf0f1'; ctx.save(); ctx.translate(cx, cy); ctx.rotate(-Math.atan2(dir.z, dir.x) - Math.PI/2);
            ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(4, 5); ctx.lineTo(0, 3); ctx.lineTo(-4, 5); ctx.fill(); ctx.restore();

            enemies.forEach(e => {
                const dx = e.position.x - camera.position.x, dz = e.position.z - camera.position.z;
                if (Math.abs(dx) < range && Math.abs(dz) < range) {
                    ctx.fillStyle = '#' + e.material.color.getHexString();
                    ctx.beginPath(); 
                    if(e.type === 'pulse') { ctx.moveTo(cx + dx*scale, cy + dz*scale - 4); ctx.lineTo(cx + dx*scale + 4, cy + dz*scale); ctx.lineTo(cx + dx*scale, cy + dz*scale + 4); ctx.lineTo(cx + dx*scale - 4, cy + dz*scale); } 
                    else { ctx.arc(cx + dx * scale, cy + dz * scale, e.type==='tank'?5:3, 0, Math.PI * 2); }
                    ctx.fill();
                }
            });
            items.forEach(i => {
                const dx = i.position.x - camera.position.x, dz = i.position.z - camera.position.z;
                if (Math.abs(dx) < range && Math.abs(dz) < range) {
                    ctx.fillStyle = i.isAmmo ? '#ffff00' : '#' + i.material.color.getHexString();
                    ctx.fillRect(cx + dx * scale - 3, cy + dz * scale - 3, 6, 6);
                }
            });
        }

        const STORAGE_KEY = 'line_shooter_scores';
        function saveScoreAndRestart() {
            let name = document.getElementById('name-input').value.toUpperCase() || "UNK";
            let scores = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
            scores.push({ name, score, date: new Date().toLocaleDateString() });
            scores.sort((a, b) => b.score - a.score);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(scores.slice(0, 10)));
            const table = document.getElementById('leaderboard-table');
            table.innerHTML = `<tr><th>RANK</th><th>NAME</th><th>SCORE</th></tr>`;
            scores.slice(0, 5).forEach((s, i) => table.innerHTML += `<tr><td>#${i+1}</td><td>${s.name}</td><td>${s.score}</td></tr>`);
            document.getElementById('input-section').style.display = 'none';
            document.getElementById('leaderboard-section').style.display = 'block';
        }
        function endGame() {
            isGameOver = true; controls.unlock();
            document.getElementById('blocker').style.display = 'flex';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('final-score').innerText = score;
            document.getElementById('input-section').style.display = 'block';
            document.getElementById('leaderboard-section').style.display = 'none';
        }
        window.saveScoreAndRestart = saveScoreAndRestart;
        window.restartGame = function() { location.reload(); };
        function updateHighScoreDisplay() {
            const s = JSON.parse(localStorage.getItem(STORAGE_KEY)||"[]");
            if(s.length) document.getElementById('high-score-display').innerText = `TOP: ${s[0].name} - ${s[0].score}`;
        }
        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    </script>
</body>
</html>
